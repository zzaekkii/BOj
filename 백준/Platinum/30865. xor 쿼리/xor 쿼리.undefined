use std::io::{self, Read, Write};

const MX: usize = 31;
const NONE: usize = 0;
const ROOT: usize = 1;

#[derive(Default)]
struct Node {
    next: [usize; 2],
    cnt: usize,
}

struct Trie {
    nodes: Vec<Node>,
}

impl Trie {
    fn new(n: usize) -> Self {
        let mut nodes = Vec::with_capacity(n * (MX + 1) + 2);
        nodes.push(Node::default());
        nodes.push(Node::default());
        Trie { nodes }
    }

    fn insert(&mut self, x: usize) {
        let mut cur = ROOT;
        self.nodes[cur].cnt += 1;

        for i in (0..=MX).rev() {
            let b = (x >> i) & 1usize;

            if self.nodes[cur].next[b] == NONE {
                self.nodes[cur].next[b] = self.nodes.len();
                self.nodes.push(Node::default());
            }

            cur = self.nodes[cur].next[b];
            self.nodes[cur].cnt += 1;
        }
    }

    fn erase(&mut self, x: usize) {
        let mut cur = ROOT;
        self.nodes[cur].cnt -= 1;

        for i in (0..=MX).rev() {
            let b = (x >> i) & 1usize;

            cur = self.nodes[cur].next[b];
            self.nodes[cur].cnt -= 1;
        }
    }

    fn find_kth_xor(&self, x: usize, mut k: usize) -> usize {
        let mut cur = ROOT;
        let mut res = 0usize;

        for i in (0..=MX).rev() {
            let b = (x >> i) & 1usize;
            let target = b ^ 1;

            let nxt = self.nodes[cur].next[target];
            let top_cnt = if nxt == NONE { 0 } else { self.nodes[nxt].cnt };

            if top_cnt >= k {
                res |= 1 << i;
                cur = nxt;
            } else {
                k -= top_cnt;
                cur = self.nodes[cur].next[b];
            }
        }

        res
    }
}

fn main() {
    let mut input = String::new();
    io::stdin().read_to_string(&mut input).unwrap();
    let mut iter = input.split_ascii_whitespace();

    let n: usize = iter.next().unwrap().parse().unwrap();
    let mut trie = Trie::new(n);

    let mut arr = Vec::<usize>::with_capacity(n);
    for _ in 0..n {
        let num: usize = iter.next().unwrap().parse().unwrap();
        trie.insert(num);
        arr.push(num);
    }

    let mut out = io::BufWriter::new(io::stdout().lock());
    let q: usize = iter.next().unwrap().parse().unwrap();
    for _ in 0..q {
        let operator: usize = iter.next().unwrap().parse().unwrap();

        match operator {
            1 => {
                let idx: usize = iter.next().unwrap().parse().unwrap();
                let x: usize = iter.next().unwrap().parse().unwrap();

                trie.erase(arr[idx - 1]);
                arr[idx - 1] = x;
                trie.insert(x);
            }
            2 => {
                let k: usize = iter.next().unwrap().parse().unwrap();
                let x: usize = iter.next().unwrap().parse().unwrap();
                writeln!(out, "{}", trie.find_kth_xor(x, k)).unwrap();
            }
            _ => unreachable!(),
        }
    }
}
