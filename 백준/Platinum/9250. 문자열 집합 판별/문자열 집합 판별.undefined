use std::collections::VecDeque;
use std::io::{self, Read, Write};

#[derive(Default)]
struct Node {
    next: [usize; 26],
    fail: usize,
    end: bool,
}

struct Trie {
    nodes: Vec<Node>,
}

impl Trie {
    fn new() -> Self {
        Self {
            nodes: vec![Node::default()],
        }
    }

    fn insert(&mut self, s: &str) {
        let bytes = s.as_bytes();
        let mut cur = 0usize;

        for &c in bytes {
            let idx = (c - b'a') as usize;

            if self.nodes[cur].next[idx] == 0 {
                self.nodes[cur].next[idx] = self.nodes.len();
                self.nodes.push(Node::default());
            }

            cur = self.nodes[cur].next[idx];
        }

        self.nodes[cur].end = true;
    }

    // aho-corasick
    fn build_fail(&mut self) {
        let mut queue = VecDeque::new();

        for i in 0..26 {
            let nxt = self.nodes[0].next[i];

            if nxt != 0 {
                queue.push_back(nxt);
            }
        }

        while let Some(cur) = queue.pop_front() {
            let f = self.nodes[cur].fail;

            for i in 0..26 {
                let nxt = self.nodes[cur].next[i];

                if nxt != 0 {
                    // 자식에서의 고민은 이미 부모에서 이뤄진 상태
                    self.nodes[nxt].fail = self.nodes[f].next[i];

                    if self.nodes[self.nodes[nxt].fail].end {
                        self.nodes[nxt].end = true;
                    }

                    queue.push_back(nxt);
                } else {
                    self.nodes[cur].next[i] = self.nodes[f].next[i];
                }
            }
        }
    }
}

fn main() {
    let mut input = String::new();
    io::stdin().read_to_string(&mut input).unwrap();
    let mut iter = input.split_whitespace();

    let n: usize = iter.next().unwrap().parse().unwrap();
    let mut trie = Trie::new();

    for _ in 0..n {
        let s = iter.next().unwrap();
        trie.insert(s);
    }

    trie.build_fail();

    let q: usize = iter.next().unwrap().parse().unwrap();
    let mut out = io::BufWriter::new(io::stdout().lock());

    for _ in 0..q {
        let text = iter.next().unwrap();
        let bytes = text.as_bytes();
        let mut found = false;
        let mut cur = 0usize;

        for &c in bytes {
            let idx = (c - b'a') as usize;
            cur = trie.nodes[cur].next[idx];

            if trie.nodes[cur].end {
                found = true;
                break;
            }
        }

        writeln!(out, "{}", if found { "YES" } else { "NO" }).unwrap();
    }
}
