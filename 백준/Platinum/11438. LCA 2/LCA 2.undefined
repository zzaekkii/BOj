use std::{collections::VecDeque, io::{self, Read, Write}};

const LOG: usize = 17;
const ROOT: usize = 1;

fn get_lca(
    mut a: usize,
    mut b: usize,
    depth: &[usize],
    parent: &[Vec<usize>],
) -> usize {
    if depth[b] < depth[a] {
        std::mem::swap(&mut a, &mut b);
    }
    
    let diff = depth[b] - depth[a];
    for k in 0..LOG {
        if diff & (1 << k) != 0 {
            b = parent[k][b];
        }
    }

    if a == b {
        return a;
    }

    for k in (0..LOG).rev() {
        if parent[k][a] != parent[k][b] {
            a = parent[k][a];
            b = parent[k][b];
        }
    }

    parent[0][a]
}

fn main() {
    let mut input = String::new();
    io::stdin().read_to_string(&mut input).unwrap();
    let mut iter = input.split_ascii_whitespace();

    let n: usize = iter.next().unwrap().parse().unwrap();
    let mut graph = vec![Vec::<usize>::new(); n + 1];
    let mut depth = vec![0usize; n + 1];
    let mut parent = vec![vec![0usize; n + 1]; LOG];

    for _ in 0..n - 1 {
        let a: usize = iter.next().unwrap().parse().unwrap();
        let b: usize = iter.next().unwrap().parse().unwrap();
        graph[a].push(b);
        graph[b].push(a);
    }

    let mut q = VecDeque::<usize>::new();
    q.push_back(ROOT);
    depth[ROOT] = 0;
    parent[0][ROOT] = 0;

    while let Some(cur) = q.pop_front() {
        for &nxt in &graph[cur] {
            if nxt == parent[0][cur] {
                continue;
            }

            depth[nxt] = depth[cur] + 1;
            parent[0][nxt] = cur;
            q.push_back(nxt);
        }
    }

    for k in 1..LOG {
        for i in 1..=n {
            let p = parent[k - 1][i];
            parent[k][i] = if p == 0 { 0 } else { parent[k - 1][p] };
        }
    }

    let m: usize = iter.next().unwrap().parse().unwrap();
    let mut out = io::BufWriter::new(io::stdout().lock());
    for _ in 0..m {
        let a: usize = iter.next().unwrap().parse().unwrap();
        let b: usize = iter.next().unwrap().parse().unwrap();

        writeln!(out, "{}", get_lca(a, b, &depth, &parent)).unwrap();
    }
}
