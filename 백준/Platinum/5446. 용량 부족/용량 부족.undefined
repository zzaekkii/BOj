use std::io::{self, Read, Write};

#[derive(Default)]
struct Node {
    next: Vec<(u8, usize)>,
    total: usize,
    del: usize,
    end_del: bool,
}

fn insert(trie: &mut Vec<Node>, s: &str, is_del: bool) {
    let bytes = s.as_bytes();
    let mut cur = 0usize;

    trie[cur].total += 1;
    if is_del {
        trie[cur].del += 1;
    }

    for &c in bytes {
        let mut exist = None;

        for &(ch, idx) in &trie[cur].next {
            if ch == c {
                exist = Some(idx);
                break;
            }
        }

        let nxt = match exist {
            Some(idx) => idx,
            None => {
                let idx = trie.len();
                trie.push(Node::default());
                trie[cur].next.push((c, idx));
                idx
            }
        };

        cur = nxt;
        trie[cur].total += 1;
        if is_del {
            trie[cur].del += 1;
        }
    }

    if is_del {
        trie[cur].end_del = true;
    }
}

fn dfs(trie: &Vec<Node>, idx: usize) -> usize {
    let cur = &trie[idx];

    if cur.del > 0 && cur.del == cur.total {
        return 1;
    }

    let mut res = 0usize;

    if cur.end_del {
        res += 1;
    }

    for &(_, nxt) in &cur.next {
        res += dfs(trie, nxt);
    }

    res
}

fn main() {
    let mut input = String::new();
    io::stdin().read_to_string(&mut input).unwrap();
    let mut iter = input.split_whitespace();

    let t: usize = iter.next().unwrap().parse().unwrap();
    let mut output = io::BufWriter::new(io::stdout());

    for _ in 0..t {
        let mut trie = vec![Node::default()];

        let n1: usize = iter.next().unwrap().parse().unwrap();
        for _ in 0..n1 {
            insert(&mut trie, iter.next().unwrap(), true);
        }

        let n2: usize = iter.next().unwrap().parse().unwrap();
        for _ in 0..n2 {
            insert(&mut trie, iter.next().unwrap(), false);
        }

        let ans = dfs(&trie, 0);
        writeln!(output, "{}", ans).unwrap();
    }
}
