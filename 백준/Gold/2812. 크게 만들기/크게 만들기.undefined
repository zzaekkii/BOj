use std::io::{self, Read, Write};

fn main() {
    let mut buf = Vec::new();
    io::stdin().read_to_end(&mut buf).unwrap();

    let mut tokens = buf
        .split(|b| *b == b' ' || *b == b'\n')
        .filter(|s| !s.is_empty());

    let n: usize = parse_usize(tokens.next().unwrap());
    let mut k: usize = parse_usize(tokens.next().unwrap());

    let num = tokens.next().unwrap();

    let mut stack: Vec<u8> = Vec::with_capacity(n);

    for &digit in num {
        while k > 0 && !stack.is_empty() && *stack.last().unwrap() < digit {
            stack.pop();
            k -= 1;
        }
        stack.push(digit);
    }

    let final_len = stack.len() - k;
    let result = String::from_utf8(stack[..final_len].to_vec()).unwrap();

    let stdout = io::stdout();
    let mut out = io::BufWriter::new(stdout.lock());
    writeln!(out, "{}", result).unwrap();
}

fn parse_usize(bytes: &[u8]) -> usize {
    let mut n = 0usize;

    for &b in bytes {
        n = n * 10 + (b - b'0') as usize;
    }

    n
}
